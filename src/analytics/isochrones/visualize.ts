import { Delaunay } from "d3-delaunay";
import { RoutableTileNode } from "../../entities/tiles/node";
import RoutableTileRegistry from "../../entities/tiles/registry";
import ILocation from "../../interfaces/ILocation";
import { IPathTree } from "../../pathfinding/pathfinder";
import UnionFind from "../../util/UnionFind";
import { pointsOfTriangle } from "./util";

// we make extensive use of the Delaunator library which uses indexes for everything
// we'll need this to get the corresponding RoutableTileNode for a given index
type NodeList = RoutableTileNode[];

// a list of boolean values, indicating whether or not the node with a given index has a specific label
type NodeLabelList = boolean[];

// A cluster of routable tile nodes
type NodeCluster = Set<number>;

// A ring is a list of connected geographical points.
type Ring = ILocation[];

// A polygon is represented as a list of rings.
// The first being the outer ring, the others being holes.
type Polygon = Ring[];

export function visualizeIsochrone(registry: RoutableTileRegistry, pathTree: IPathTree, maxCost: number) {
    /**
     * Isochrones are generated by applying a delaunay triangulisation to the road network nodes,
     * and then connecting edges between between points that lie on the edge of the isochrone.
     * Union-Find (= disjoint set) is used to find clusters of external/internal nodes.
     * Each cluster will form one ring in the isochrone.
     */

    const nodes: NodeList = [];
    const costs = {};
    for (const [id, cost] of Object.entries(pathTree)) {
        const node = registry.getNode(id);
        if (node) {
            nodes.push(node);
            costs[node.id] = cost;
        }
    }

    const delaunay = createTriangulation(nodes);
    const internalNodes: NodeLabelList = nodes.map((node) => costs[node.id] < maxCost);
    const externalNodes: NodeLabelList = internalNodes.map((v) => !v);
    const internalClusters = clusterNodes(nodes, internalNodes, delaunay);
    const externalClusters = clusterNodes(nodes, externalNodes, delaunay);

    const polygons: Polygon[] = internalClusters
        .filter((cluster) => cluster.size > 1)
        .map((internalCluster) =>
            createPolygon(nodes, internalCluster, externalClusters, delaunay),
        );

    const points = [];
    for (const nodeId of Array(nodes.length).keys()) {
        if (externalNodes[nodeId]) {
            points.push(nodes[nodeId]);
        }
    }

    return {
        isochrones: polygons.filter((p) => p.length > 0),
        points,
    };
}

function createTriangulation(nodes: NodeList): Delaunay {
    function getX(p: ILocation) {
        return p.longitude;
    }

    function getY(p: ILocation) {
        return p.latitude;
    }

    return Delaunay.from(nodes, getX, getY);
}

function clusterNodes(allNodes: NodeList, relevantNodes: NodeLabelList, delaunay: Delaunay): NodeCluster[] {
    /**
     * Uses Union-Find to cluster the given (relevant) nodes based on the Delaunay triangulisation of all nodes.
     * Returns an array of clusters.
     */
    const forest = new UnionFind(allNodes.length);

    for (const nodeIndex of Array(allNodes.length).keys()) {
        if (relevantNodes[nodeIndex]) {
            const neighbors = delaunay.neighbors(nodeIndex);
            for (const neighbor of neighbors) {
                if (relevantNodes[neighbor]) {
                    forest.union(nodeIndex, neighbor);
                }
            }
        }
    }

    const clusters = forest.getClusters();

    for (const key of Object.keys(clusters)) {
        if (!relevantNodes[key]) {
            delete clusters[key];
        }
    }

    return Object.values(clusters);
}

function createPolygon(
    nodes: NodeList,
    internalNodes: NodeCluster,
    externalClusters: NodeCluster[],
    delaunay: Delaunay,
): Polygon {
    /**
     * Creates a polygon for the given cluster of nodes that lie in an isochrone.
     */
    const rings = [];

    // each cluster of external nodes yields a single ring.
    // there's exactly one on the outside of the internal nodes cluster (because union-find)
    // the others will form holes
    for (const externalNodes of externalClusters) {

        // border nodes are internal nodes that lie on the edge of the isochrone
        // i.e., one of their neighbors is an external node.
        const borderNodes: NodeCluster = new Set();
        for (const nodeIndex of Array(nodes.length).keys()) {
            if (!externalNodes.has(nodeIndex) && internalNodes.has(nodeIndex)) {
                for (const neighbor of delaunay.neighbors(nodeIndex)) {
                    if (externalNodes.has(neighbor)) {
                        borderNodes.add(nodeIndex);
                    }
                }
            }
        }

        // border triangles are triangles on the edge of the isochrone
        // i.e., they have one external and one border node
        // this essentially forms a triangle strip
        const numTriangles = delaunay.triangles.length / 3;
        const borderTriangles = new Set();

        for (const triangleIndex of Array(numTriangles).keys()) {
            let numBorder = 0;
            let numExternal = 0;
            for (const nodeIndex of pointsOfTriangle(delaunay, triangleIndex)) {
                if (borderNodes.has(nodeIndex)) {
                    numBorder += 1;
                } else if (externalNodes.has(nodeIndex)) {
                    numExternal += 1;
                }
            }
            if (numBorder > 1) {
                borderTriangles.add(triangleIndex);
            }
        }

        rings.push(createRing(nodes, borderTriangles, delaunay));
    }

    // FIXME, the ring with the most nodes might not always be the outer ring
    return rings
        .filter((r) => r.length > 0)
        .sort((a, b) => b.length - a.length);
}

function createRing(nodes: NodeList, borderTriangles, delaunay): Ring {
    /**
     * This problem is probably NP-complete as it's very close to the hamiltonian cycle problem.
     * Our approach is based on a conventional way of constructing a concave hull.
     * We go from node to node, each time going for the largest right-hand turn possible.
     * The result is fairly efficient, but _might_ not always work.
     * It could use a theoretic proof of correctness, along with a proof that it isn't NP-complete after all.
     */

    const shellNodes = findShell(borderTriangles, delaunay);

    if (shellNodes.size === 0) {
        return [];
    }

    // pick the bottom-most shell node
    const beginNode = Array.from(shellNodes)
        .reduce((prev, current) => nodes[prev].latitude > nodes[current].latitude ? current : prev);

    // going east
    let currentBearing = 90;
    let currentNode = beginNode;

    const ring = [beginNode];
    const bearings = [currentBearing]; // store all these because we might backtrack
    const visited = new Set(ring);  // to avoid infinite loops

    const nodesToVisit = new Set(delaunay.neighbors(beginNode)); // the stop condition
    let nodesToVisitCount = 0;

    while (nodesToVisitCount < 2) {
        const neighbors = delaunay.neighbors(currentNode);

        // find the neighbor with the largest right-hand turn
        // only visiting each node once
        let bestAngle = -Infinity;
        let bestNeighbor;
        for (const neighbor of neighbors) {
            if (shellNodes.has(neighbor) && !visited.has(neighbor)) {
                const angle = bearingBetween(nodes, currentNode, neighbor, currentBearing + 180);
                if (angle > bestAngle) {
                    bestAngle = angle;
                    bestNeighbor = neighbor;
                }
            }
        }

        if (bestNeighbor === undefined) {
            // we hit a dead end, backtrack
            if (ring.length > 1) {
                ring.pop();
                bearings.pop();
                currentNode = ring[ring.length - 1];
                currentBearing = bearings[bearings.length - 1];
            } else {
                // we hit a very dead end, abort
                break;
            }
        } else {
            currentBearing = bearingBetween(nodes, currentNode, bestNeighbor);
            currentNode = bestNeighbor;
            bearings.push(currentBearing);
            ring.push(currentNode);
            visited.add(currentNode);

            if (nodesToVisit.has(currentNode)) {
                nodesToVisitCount += 1;
            }
        }
    }

    return ring.map((nodeIndex) => nodes[nodeIndex]);
}

function findShell(borderTriangles, delaunay): NodeCluster {
    const shellNodes = new Set();

    for (const t of borderTriangles) {
        const [node1, node2, node3] = pointsOfTriangle(delaunay, t);
        shellNodes.add(node1);
        shellNodes.add(node2);
        shellNodes.add(node3);
    }

    return shellNodes;
}

function bearingBetween(nodes, node1, node2, referenceBearing = 0) {
    const factor = Math.PI / 180;

    const point1 = nodes[node1];
    const point2 = nodes[node2];

    const lat1 = point1.latitude;
    const lat2 = point2.latitude;
    const lon1 = point1.longitude;
    const lon2 = point2.longitude;

    const φ1 = lat1 * factor;
    const φ2 = lat2 * factor;
    const Δλ = (lon2 - lon1) * factor;

    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x = Math.cos(φ1) * Math.sin(φ2) -
        Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
    const brng = Math.atan2(y, x) / factor - referenceBearing;
    return (brng + 720) % 360;
}
